#!/usr/bin/env python3
"""
Script to fix the broken ultra_strict_detector.py file
Run this script from the project root directory
"""

import os
from pathlib import Path

# The correct ultra_strict_detector.py content
CORRECTED_CODE = '''import argparse
import time
from pathlib import Path
import cv2
import torch
from ultralytics import YOLO
import os

class KFramesValidator:
    def __init__(self, k=20, min_ratio=0.9):
        self.k = k
        self.min_ratio = min_ratio
        self.history = []
        self.stable_count = 0

    def update(self, has_detection):
        self.history.append(has_detection)
        if len(self.history) > self.k:
            self.history.pop(0)
        
        if len(self.history) == self.k:
            positive_ratio = sum(self.history) / len(self.history)
            if positive_ratio >= self.min_ratio:
                self.stable_count += 1
                return True
            else:
                self.stable_count = 0
                return False
        return False

class UltraStrictCylinderDetector:
    def __init__(self, weights, conf_threshold=0.25, k=20, min_ratio=0.5,
                 min_aspect_ratio=1.2, max_aspect_ratio=4.0,
                 min_width=40, max_width=300, min_height=80,
                 min_center_x_ratio=0.1, max_center_x_ratio=0.9,
                 min_center_y_ratio=0.1, max_center_y_ratio=0.9):
        
        # Auto-detect best device
        self.device = 0 if torch.cuda.is_available() else "cpu"
        
        # Load model with fallback
        weights_path = Path(weights)
        if not weights_path.exists():
            print(f"[ultra_strict] Warning: weights not found: {weights}")
            print("[ultra_strict] Falling back to 'yolo11n.pt'")
            weights = "yolo11n.pt"
            
            # Check if fallback exists
            if not Path(weights).exists():
                print("[ultra_strict] Error: No model weights found!")
                print("Please ensure either trained weights or yolo11n.pt exists")
                raise FileNotFoundError("No model weights available")
        
        try:
            self.model = YOLO(weights)
            print(f"[ultra_strict] Model loaded successfully: {weights}")
        except Exception as e:
            print(f"[ultra_strict] Error loading model: {e}")
            raise
        
        self.validator = KFramesValidator(k=k, min_ratio=min_ratio)
        self.conf_threshold = conf_threshold
        self.min_aspect_ratio = min_aspect_ratio
        self.max_aspect_ratio = max_aspect_ratio
        self.min_width = min_width
        self.max_width = max_width
        self.min_height = min_height
        self.min_center_x_ratio = min_center_x_ratio
        self.max_center_x_ratio = max_center_x_ratio
        self.min_center_y_ratio = min_center_y_ratio
        self.max_center_y_ratio = max_center_y_ratio
        
        device_name = "CUDA" if self.device == 0 else "CPU"
        print(f"[ultra_strict] Device: {device_name}")
        print(f"[ultra_strict] Starting with conf={self.conf_threshold}, k={k}, min_ratio={min_ratio}")
        print(f"[ultra_strict] Ultra-strict mode: Only detects tall, centered objects")

    def detect(self, frame):
        """Detect cylinders in frame with ultra-strict validation"""
        h_frame, w_frame = frame.shape[:2]
        
        # Run YOLO detection
        results = self.model.predict(source=frame, conf=self.conf_threshold, device=self.device, verbose=False)
        r = results[0]
        filtered_boxes = []
        
        # Apply geometric filtering
        if hasattr(r, "boxes") and r.boxes is not None and len(r.boxes) > 0:
            for box in r.boxes:
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                w, h = x2 - x1, y2 - y1
                aspect_ratio = h / (w + 1e-6)  # Prevent division by zero
                center_x = (x1 + x2) / 2 / w_frame
                center_y = (y1 + y2) / 2 / h_frame

                # Ultra-strict validation checks
                size_valid = (self.min_width <= w <= self.max_width and h >= self.min_height)
                aspect_valid = (self.min_aspect_ratio <= aspect_ratio <= self.max_aspect_ratio)
                position_valid = (self.min_center_x_ratio <= center_x <= self.max_center_x_ratio and
                                self.min_center_y_ratio <= center_y <= self.max_center_y_ratio)
                
                if size_valid and aspect_valid and position_valid:
                    filtered_boxes.append(box)

        # Update results with filtered boxes
        if filtered_boxes and hasattr(r, "boxes") and r.boxes is not None:
            # Find indices of filtered boxes in original results
            box_indices = []
            for filtered_box in filtered_boxes:
                for i, box in enumerate(r.boxes):
                    if torch.equal(box.data, filtered_box.data):
                        box_indices.append(i)
                        break
            
            if box_indices:
                r.boxes = r.boxes[torch.tensor(box_indices)]
            else:
                r.boxes = None
        else:
            r.boxes = None

        # Update temporal validation
        has_det = (r.boxes is not None) and len(r.boxes) > 0
        stable = self.validator.update(has_det)
        
        return r, stable

    def run_webcam(self, source=0, use_directshow=True):
        """Run detection on webcam feed"""
        # Setup camera
        if use_directshow and source == 0:
            cap = cv2.VideoCapture(source, cv2.CAP_DSHOW)
        else:
            cap = cv2.VideoCapture(source)
        
        if not cap.isOpened():
            print(f"Error: Could not open camera {source}")
            print("Try:")
            print("  - Different camera index (--source 1, --source 2)")
            print("  - Remove --directshow flag")
            print("  - Check camera permissions")
            return

        print("Controls:")
        print("  - Press 'q' to quit")
        print("  - Press 's' to save current frame")
        print("  - Press 'c' to change confidence threshold")
        print("Ultra-strict mode: Only tall, centered objects will be detected")
        print()
        
        total_detections = 0
        frame_count = 0
        
        try:
            while True:
                ret, frame = cap.read()
                if not ret:
                    print("Error: Could not read frame from camera")
                    break
                    
                frame_count += 1
                result, stable = self.detect(frame)
                
                # Draw detections
                if hasattr(result, 'boxes') and result.boxes is not None and len(result.boxes) > 0:
                    for box in result.boxes:
                        x1, y1, x2, y2 = map(int, box.xyxy[0])
                        conf = float(box.conf[0])
                        
                        # Draw bounding box
                        color = (0, 255, 0) if stable else (0, 255, 255)  # Green if stable, yellow if not
                        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                        
                        # Draw confidence and stability
                        label = f"Cylinder: {conf:.2f}"
                        if stable:
                            label += " [STABLE]"
                            total_detections += 1
                        
                        cv2.putText(frame, label, (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
                
                # Draw status information
                status = f"Frame: {frame_count} | Stable: {stable} | Total: {total_detections}"
                cv2.putText(frame, status, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
                
                # Draw confidence threshold
                conf_text = f"Confidence: {self.conf_threshold:.2f}"
                cv2.putText(frame, conf_text, (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
                
                cv2.imshow("Ultra-Strict Gas Cylinder Detector", frame)
                
                # Handle keyboard input
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
                elif key == ord('s'):
                    timestamp = int(time.time())
                    filename = f"ultra_strict_detection_{timestamp}.jpg"
                    cv2.imwrite(filename, frame)
                    print(f"Frame saved as {filename}")
                elif key == ord('c'):
                    print(f"\\nCurrent confidence threshold: {self.conf_threshold}")
                    try:
                        new_conf = float(input("Enter new confidence threshold (0.0-1.0): "))
                        if 0.0 <= new_conf <= 1.0:
                            self.conf_threshold = new_conf
                            print(f"Confidence threshold updated to {new_conf}")
                        else:
                            print("Invalid confidence value. Must be between 0.0 and 1.0")
                    except ValueError:
                        print("Invalid input. Please enter a number.")
                    except KeyboardInterrupt:
                        break
                        
        except KeyboardInterrupt:
            print("\\nStopping detection...")
        finally:
            cap.release()
            cv2.destroyAllWindows()
            print(f"[ultra_strict] Session ended. Total stable detections: {total_detections}")

def main():
    parser = argparse.ArgumentParser(description="Ultra-Strict Gas Cylinder Detector")
    parser.add_argument("--weights", type=str, default="yolo11n.pt",
                        help="Path to model weights")
    parser.add_argument("--source", type=str, default="0", 
                        help="Camera index (0, 1, 2...) or video file path")
    parser.add_argument("--conf", type=float, default=0.25, 
                        help="Confidence threshold (0.0-1.0)")
    parser.add_argument("--k", type=int, default=20, 
                        help="Number of frames for stability validation")
    parser.add_argument("--min_ratio", type=float, default=0.5, 
                        help="Minimum ratio for stable detection")
    parser.add_argument("--directshow", action="store_true", 
                        help="Force DirectShow on Windows webcams")
    
    args = parser.parse_args()
    
    # Convert source to int if it's a digit
    if args.source.isdigit():
        source = int(args.source)
    else:
        source = args.source
    
    # Create detector
    try:
        detector = UltraStrictCylinderDetector(
            weights=args.weights,
            conf_threshold=args.conf,
            k=args.k,
            min_ratio=args.min_ratio
        )
    except Exception as e:
        print(f"Error creating detector: {e}")
        print("Please check that model weights exist or yolo11n.pt is available")
        return
    
    # Run detection
    detector.run_webcam(source=source, use_directshow=args.directshow)

if __name__ == "__main__":
    main()
'''

def main():
    print("🔧 Ultra-Strict Detector File Fixer")
    print("=" * 50)
    
    # Check if we're in the right directory
    if not os.path.exists("src"):
        print("❌ Error: src/ directory not found")
        print("Please run this script from the project root directory")
        print("(GasCylinderCV_yolo11/GasCylinderCV_yolo11/)")
        return False
    
    # Backup the existing file
    src_file = Path("src/ultra_strict_detector.py")
    backup_file = Path("src/ultra_strict_detector.py.backup")
    
    if src_file.exists():
        try:
            import shutil
            shutil.copy2(src_file, backup_file)
            print(f"✅ Backed up existing file to {backup_file}")
        except Exception as e:
            print(f"⚠️  Warning: Could not create backup: {e}")
    
    # Write the corrected file
    try:
        with open(src_file, 'w', encoding='utf-8') as f:
            f.write(CORRECTED_CODE)
        print(f"✅ Created corrected {src_file}")
    except Exception as e:
        print(f"❌ Error writing file: {e}")
        return False
    
    # Test the file syntax
    try:
        import subprocess
        result = subprocess.run(['python', '-m', 'py_compile', str(src_file)], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            print("✅ File syntax is correct!")
        else:
            print(f"❌ Syntax error: {result.stderr}")
            return False
    except Exception as e:
        print(f"⚠️  Could not test syntax: {e}")
    
    print("\n🎉 File fixed successfully!")
    print("\nNow you can run:")
    print("  python src/ultra_strict_detector.py --help")
    print("  python src/ultra_strict_detector.py")
    
    return True

if __name__ == "__main__":
    main()